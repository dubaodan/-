# Homework4

## 1. 用python实现udp校验和

[源码](https://github.com/dubaodan/-/blob/master/homework5/checksum.py)

## 2. 选做两道题目

### P4
a.01011100+01100101 = 11000001，反码为00111110

b.11011010+01100101 = 01000000，反码为10111111

c.01011100->01111100，01100101->01000101


### P6
可以看到这个错误的接收方在处于等待下层的0的状态时，无论是接收到损坏的数据还是有1的序号的数据，都会返回NAK，所以会产生如下错误：如果发送方处于等待上层的调用1，发送了数据，前往等待ACK或NAK1的状态，然后接收方接收到1这个数据，前往等待来自下层的0的状态，并且发送了一个ACK，而这个ACK是损坏了的，那么发送方接收到这个损坏了的ACK之后，会重新发送1这个数据，然而这个时候接受方处于等待来自下层的0的状态，所以会发送NAK，发送方接收到NAK会在此发送1的数据，然后接收方再发送NAK，就会这样循环死锁下去
